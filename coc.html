<!doctype html>
<meta charset="utf-8">
<title>SVG手書き文字ジェネレーター（1文字ずつ・回転フェード付き）</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans","Apple Color Emoji","Segoe UI Emoji";margin:24px;line-height:1.6}
  h1{font-size:18px;margin:0 0 12px}
  fieldset{border:1px solid #ccc;border-radius:8px;padding:12px;margin:0 0 16px}
  label{display:block;font-size:13px;margin:6px 0 2px}
  input,select,button,textarea{font:inherit}
  input[type="text"],input[type="number"],select{width:100%;box-sizing:border-box;padding:6px;border:1px solid #bbb;border-radius:6px}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .preview{border:1px dashed #bbb;border-radius:8px;display:flex;align-items:center;justify-content:center;background:#fafafa;min-height:460px}
  textarea{width:100%;box-sizing:border-box;height:200px;padding:8px;border:1px solid #bbb;border-radius:8px;font-family:ui-monospace,SFMono-Regular,Consolas,Monaco,Menlo,monospace;font-size:12px;white-space:pre}
  .actions{display:flex;gap:8px;flex-wrap:wrap}
  .hint{font-size:12px;color:#555}
</style>

<h1>SVG手書き文字ジェネレーター（1文字ずつ・回転フェード付き）</h1>

<fieldset>
  <legend>設定</legend>
  <div class="row">
    <div>
      <label>① テキスト</label>
      <input id="text" type="text" value="Call of Cthulhu">
      <div class="hint">横書き。空白は間として扱います（描画はしません）。</div>
    </div>
    <div>
      <label>② 文字色</label>
      <input id="color" type="text" value="#000000">
      <div class="hint">例: #000, black, rgb(0,0,0) など</div>
    </div>
  </div>

  <div class="row">
    <div>
      <label>③ 文字サイズ（px）</label>
      <input id="fontSize" type="number" value="72" min="8" step="1">
      <div class="hint">推奨：36〜120</div>
    </div>
    <div>
      <label>④ フォント</label>
      <select id="fontFamily">
        <option value="serif" selected>serif（明朝系）</option>
        <option value="sans-serif">sans-serif（ゴシック系）</option>
        <option value="monospace">monospace</option>
        <option value="Georgia, serif">Georgia</option>
        <option value="Times New Roman, serif">Times New Roman</option>
        <option value="Arial, Helvetica, sans-serif">Arial</option>
        <option value="Tahoma, sans-serif">Tahoma</option>
        <option value="Verdana, sans-serif">Verdana</option>
      </select>
      <div class="hint">OSにあるフォントを使用します。</div>
    </div>
  </div>

  <div class="row">
    <div>
      <label>⑤ 文字間（px）</label>
      <input id="letterSpacing" type="number" value="2" step="0.5">
      <div class="hint">正の値で広く、負の値で狭く。</div>
    </div>
    <div>
      <label>描画時間（1文字の基準秒）</label>
      <input id="baseDur" type="number" value="0.75" step="0.05" min="0.05">
      <div class="hint">幅に応じて自動補正されます。</div>
    </div>
  </div>

  <div class="row">
    <div>
      <label>キャンバス（固定）</label>
      <input disabled value="768 × 432（16:9・24px倍数）">
    </div>
    <div class="actions" style="align-items:end">
      <button id="build">SVGを生成</button>
      <button id="copy">SVGコードをコピー</button>
      <button id="download">SVGをダウンロード</button>
    </div>
  </div>
</fieldset>

<fieldset>
  <legend>⑥ プレビュー（実寸 768×432）</legend>
  <div class="preview" id="previewArea">ここにSVGが表示されます</div>
</fieldset>

<fieldset>
  <legend>生成されたSVGコード</legend>
  <textarea id="code" readonly></textarea>
</fieldset>

<script>
  // 幅計測用キャンバス
  const measureCanvas = document.createElement('canvas');
  const mctx = measureCanvas.getContext('2d');
  function measureWidth(ch, size, family){
    mctx.font = `${size}px ${family}`;
    return mctx.measureText(ch).width;
  }
  function escapeXML(s){
    return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  }

  function buildSVG(){
    const txt = document.getElementById('text').value ?? '';
    const color = document.getElementById('color').value || '#000';
    const size = Math.max(8, Number(document.getElementById('fontSize').value || 72));
    const family = document.getElementById('fontFamily').value || 'serif';
    const letter = Number(document.getElementById('letterSpacing').value || 0);
    const baseDur = Math.max(0.05, Number(document.getElementById('baseDur').value || 0.75));

    const W = 768, H = 432;
    const baselineY = Math.round(H/2) + Math.round(size*0.35);

    const chars = [...txt];
    const widths = chars.map(ch => measureWidth(ch, size, family));
    const total = widths.reduce((a,b)=>a+b,0) + Math.max(0, chars.length-1)*letter;
    const startX = (W - total)/2;

    const maskStroke = Math.max(8, size * 0.38);
    const dashFor = w => Math.max(300, w * 12);
    const durFor  = w => (baseDur * Math.max(0.5, Math.min(1.5, w / (size * 0.6)))).toFixed(3) + 's';

    let x = startX;
    let beginId = '0s';
    let idSeq = 0; // 非スペースのみに採番

    const defs = [];
    const outlines = [];
    const fills = [];

    chars.forEach((ch, idx) => {
      const w = widths[idx];
      if (ch === ' '){
        // スペースではIDを作らず、タイミングも進めない（描画チェーンを維持）
        x += w + letter;
        return;
      }
      const thisId = `a${++idSeq}`;
      const nextBegin = `${thisId}.end+0.08s`;
      const dash = Math.round(dashFor(w));
      const dur = durFor(w);
      const mx = Math.round(x);

      // マスク（白ストロークで塗り露出）
      defs.push(
        `<mask id="m${idSeq}">` +
        `<text x="${mx}" y="${baselineY}" font-family="${family}" font-size="${size}" fill="none" stroke="#fff" stroke-width="${maskStroke}" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="${dash}" stroke-dashoffset="${dash}">` +
        `${escapeXML(ch)}<animate attributeName="stroke-dashoffset" from="${dash}" to="0" dur="${dur}" begin="${beginId}" fill="freeze"/></text>` +
        `</mask>`
      );

      // アウトライン（書画線）
      outlines.push(
        `<text x="${mx}" y="${baselineY}" font-family="${family}" font-size="${size}" fill="none" stroke="${color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="${dash}" stroke-dashoffset="${dash}">` +
        `${escapeXML(ch)}<animate id="${thisId}" attributeName="stroke-dashoffset" from="${dash}" to="0" dur="${dur}" begin="${beginId}" fill="freeze"/></text>`
      );

      // 塗り（描いた軌跡のみ可視）
      fills.push(
        `<text x="${mx}" y="${baselineY}" font-family="${family}" font-size="${size}" fill="${color}" mask="url(#m${idSeq})">${escapeXML(ch)}</text>`
      );

      beginId = nextBegin;
      x += w + letter;
    });

    // 全体を包む <g id="all">（回転＋フェード対象）
    const lastId = idSeq > 0 ? `a${idSeq}` : null;
    const rotateDur = '2s';
    const fadeDur   = '1.5s';
    const beginAll  = lastId ? `${lastId}.end+1s` : '0s'; // 文字が無い場合でも動作

    const svg =
`<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="${W}" height="${H}" viewBox="0 0 ${W} ${H}">
  <!-- 背景は透明・SVG単体（SMIL） -->
  <defs>
    ${defs.join('\n    ')}
  </defs>

  <g id="all" transform-origin="${W/2} ${H/2}">
    <!-- 書いている線（輪郭） -->
    ${outlines.join('\n    ')}

    <!-- 塗り（描いた軌跡にだけ表示） -->
    ${fills.join('\n    ')}
  </g>

  <!-- 全体回転＋フェードアウト -->
  <animateTransform xlink:href="#all" attributeName="transform" type="rotate"
                    from="0 ${W/2} ${H/2}" to="360 ${W/2} ${H/2}"
                    dur="${rotateDur}" begin="${beginAll}" fill="freeze"/>
  <animate xlink:href="#all" attributeName="opacity"
           from="1" to="0" dur="${fadeDur}" begin="${beginAll}" fill="freeze"/>
</svg>`;

    document.getElementById('code').value = svg;
    document.getElementById('previewArea').innerHTML = svg;
  }

  document.getElementById('build').addEventListener('click', e => { e.preventDefault(); buildSVG(); });
  document.getElementById('copy').addEventListener('click', e => {
    e.preventDefault();
    const t = document.getElementById('code');
    t.select(); t.setSelectionRange(0, 999999);
    document.execCommand('copy');
  });
  document.getElementById('download').addEventListener('click', e => {
    e.preventDefault();
    const svg = document.getElementById('code').value || '';
    const blob = new Blob([svg], {type:'image/svg+xml;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'handwrite.svg';
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  });

  // 初期生成
  buildSVG();
</script>
