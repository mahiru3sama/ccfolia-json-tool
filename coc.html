<!doctype html>
<meta charset="utf-8">
<title>SVG手書き文字ジェネレーター（1文字ずつ）</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans","Apple Color Emoji","Segoe UI Emoji";margin:24px;line-height:1.6}
  h1{font-size:18px;margin:0 0 12px}
  fieldset{border:1px solid #ccc;border-radius:8px;padding:12px;margin:0 0 16px}
  label{display:block;font-size:13px;margin:6px 0 2px}
  input,select,button,textarea{font:inherit}
  input[type="text"],input[type="number"],select{width:100%;box-sizing:border-box;padding:6px;border:1px solid #bbb;border-radius:6px}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .preview{border:1px dashed #bbb;border-radius:8px;display:flex;align-items:center;justify-content:center;background:#fafafa;min-height:460px}
  textarea{width:100%;box-sizing:border-box;height:200px;padding:8px;border:1px solid #bbb;border-radius:8px;font-family:ui-monospace,SFMono-Regular,Consolas,Monaco,Menlo,monospace;font-size:12px;white-space:pre}
  .actions{display:flex;gap:8px;flex-wrap:wrap}
  .hint{font-size:12px;color:#555}
</style>

<h1>SVG手書き文字ジェネレーター（1文字ずつ・SVGだけで完結）</h1>

<fieldset>
  <legend>設定</legend>
  <div class="row">
    <div>
      <label>① テキスト</label>
      <input id="text" type="text" value="Call of Cthulhu">
      <div class="hint">横書き。空白はその分だけ間隔が空きます。</div>
    </div>
    <div>
      <label>② 文字色</label>
      <input id="color" type="text" value="#000000">
      <div class="hint">CSSカラー（例: #000, black, rgb(0,0,0) など）</div>
    </div>
  </div>

  <div class="row">
    <div>
      <label>③ 文字サイズ（px）</label>
      <input id="fontSize" type="number" value="72" min="8" step="1">
      <div class="hint">推奨：36〜120</div>
    </div>
    <div>
      <label>④ フォント</label>
      <select id="fontFamily">
        <option value="serif" selected>serif（明朝系）</option>
        <option value="sans-serif">sans-serif（ゴシック系）</option>
        <option value="monospace">monospace</option>
        <option value="Georgia, serif">Georgia</option>
        <option value="Times New Roman, serif">Times New Roman</option>
        <option value="Arial, Helvetica, sans-serif">Arial</option>
        <option value="Tahoma, sans-serif">Tahoma</option>
        <option value="Verdana, sans-serif">Verdana</option>
      </select>
      <div class="hint">GitHub Pages上でOSにあるフォントが使われます。</div>
    </div>
  </div>

  <div class="row">
    <div>
      <label>⑤ 文字間（px）</label>
      <input id="letterSpacing" type="number" value="2" step="0.5">
      <div class="hint">正の値で広く、負の値で狭く。</div>
    </div>
    <div>
      <label>描画時間（1文字あたりの基準秒）</label>
      <input id="baseDur" type="number" value="0.75" step="0.05" min="0.1">
      <div class="hint">例：0.75 なら1文字 約0.75秒。幅に応じて自動補正されます。</div>
    </div>
  </div>

  <div class="row">
    <div>
      <label>キャンバス（固定）</label>
      <input disabled value="768 × 432（16:9・24px倍数）">
      <div class="hint">要件に合わせ固定。必要ならHTMLを書き換えて他の(384n×216n)に。</div>
    </div>
    <div class="actions" style="align-items:end">
      <button id="build">SVGを生成</button>
      <button id="copy">SVGコードをコピー</button>
      <button id="download">SVGをダウンロード</button>
    </div>
  </div>
</fieldset>

<fieldset>
  <legend>⑥ プレビュー（実寸 768×432）</legend>
  <div class="preview" id="previewArea">ここにSVGが表示されます</div>
</fieldset>

<fieldset>
  <legend>生成されたSVGコード</legend>
  <textarea id="code" readonly></textarea>
</fieldset>

<script>
  // 計測用オフスクリーンCanvas（正確な文字幅の取得）
  const measureCanvas = document.createElement('canvas');
  const mctx = measureCanvas.getContext('2d');

  function measureWidth(char, size, family){
    mctx.font = `${size}px ${family}`;
    return mctx.measureText(char).width;
  }

  function buildSVG(){
    const txt = document.getElementById('text').value ?? '';
    const color = document.getElementById('color').value || '#000';
    const size = Math.max(8, Number(document.getElementById('fontSize').value || 72));
    const family = document.getElementById('fontFamily').value || 'serif';
    const letter = Number(document.getElementById('letterSpacing').value || 0);
    const baseDur = Math.max(0.05, Number(document.getElementById('baseDur').value || 0.75));

    const W = 768, H = 432;           // 16:9・24px倍数固定
    const baselineY = Math.round(H/2) + Math.round(size*0.35); // 視覚中心に置く
    // 各文字幅を計測してレイアウト
    const chars = [...txt];
    const widths = chars.map(ch => ch === ' ' ? measureWidth(' ', size, family) : measureWidth(ch, size, family));
    // 合計幅（文字間を足す。ただし最後の後ろは足さない）
    const total = widths.reduce((a,b)=>a+b,0) + Math.max(0, chars.length-1)*letter;
    const startX = (W - total)/2;

    // マスク用ストローク太さ（文字サイズに応じて）
    const maskStroke = Math.max(8, size * 0.38);
    // 目視に十分なダッシュ長（字幅比例で変化）
    const dashFor = w => Math.max(300, w * 12);
    // 文字の幅に応じて所要時間を補正（大きい字ほど長め）
    const durFor = w => (baseDur * Math.max(0.5, Math.min(1.5, w / (size * 0.6)))).toFixed(3) + 's';

    // 文字ごとに x を積み上げ
    let x = startX;
    let beginId = '0s'; // 先頭開始
    let idSeq = 0;

    let defs = [];
    let outlines = [];
    let fills = [];

    chars.forEach((ch, idx) => {
      const w = widths[idx];
      const thisId = `a${++idSeq}`;
      const nextBegin = `${thisId}.end+0.08s`;

      if(ch === ' '){
        // 空白は描画しない（位置だけ進める、次のbeginは現状維持）
        x += w + letter;
        return;
      }

      const dash = Math.round(dashFor(w));
      const dur = durFor(w);
      const mx = Math.round(x);

      // マスク（白ストロークで塗りを露出）
      defs.push(
        `<mask id="m${idSeq}">`+
        `<text x="${mx}" y="${baselineY}" font-family="${family}" font-size="${size}" fill="none" stroke="#fff" stroke-width="${maskStroke}" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="${dash}" stroke-dashoffset="${dash}">${escapeXML(ch)}<animate attributeName="stroke-dashoffset" from="${dash}" to="0" dur="${dur}" begin="${beginId}" fill="freeze"/></text>`+
        `</mask>`
      );

      // アウトライン（書いている線を見せる）
      outlines.push(
        `<text x="${mx}" y="${baselineY}" font-family="${family}" font-size="${size}" fill="none" stroke="${color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="${dash}" stroke-dashoffset="${dash}">`+
        `${escapeXML(ch)}<animate id="${thisId}" attributeName="stroke-dashoffset" from="${dash}" to="0" dur="${dur}" begin="${beginId}" fill="freeze"/></text>`
      );

      // 塗り（黒や指定色）。描いたところだけ露出
      fills.push(
        `<text x="${mx}" y="${baselineY}" font-family="${family}" font-size="${size}" fill="${color}" mask="url(#m${idSeq})">${escapeXML(ch)}</text>`
      );

      // 次文字の開始をつなぐ
      beginId = nextBegin;
      x += w + letter;
    });

    const svg =
`<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}" viewBox="0 0 ${W} ${H}">
  <!-- 背景は透明・SVG単体で完結（SMILアニメ） -->
  <defs>
    ${defs.join('\n    ')}
  </defs>

  <!-- 書いている線（輪郭） -->
  ${outlines.join('\n  ')}

  <!-- 塗り（描いた軌跡にだけ表示） -->
  ${fills.join('\n  ')}
</svg>`;

    document.getElementById('code').value = svg;
    document.getElementById('previewArea').innerHTML = svg;
  }

  function escapeXML(s){
    return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  }

  document.getElementById('build').addEventListener('click', e => { e.preventDefault(); buildSVG(); });
  document.getElementById('copy').addEventListener('click', e => {
    e.preventDefault();
    const t = document.getElementById('code');
    t.select(); t.setSelectionRange(0, 999999);
    document.execCommand('copy');
  });
  document.getElementById('download').addEventListener('click', e => {
    e.preventDefault();
    const svg = document.getElementById('code').value || '';
    const blob = new Blob([svg], {type:'image/svg+xml;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'handwrite.svg';
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  });

  // 初期生成
  buildSVG();
</script>
